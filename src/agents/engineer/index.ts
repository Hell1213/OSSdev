import { GeminiService } from '../gemini';
import { IssueAnalysis, CodeSnippet, CodeFix, FixFailure } from '../../types';
import { logger } from '../../utils/logger';
import { z } from 'zod';

export class EngineerAgent {
  constructor() { }

  async generateFix(
    issue: IssueAnalysis,
    snippets: CodeSnippet[],
    language: string,
    previousFailures: FixFailure[] = []
  ): Promise<CodeFix> {
    const model = GeminiService.getModel('gemini-2.0-flash-exp');

    const schema = z.object({
      file: z.string().describe("The file path to modify"),
      content: z.string().describe("The complete new content of the file"),
      explanation: z.string().describe("Brief explanation of the fix"),
    });

    const structuredModel = model.withStructuredOutput(schema as any);

    const prompt = `You are a senior developer fixing a bug.

Issue: ${issue.problem}
Stack: ${language}

Relevant Code:
${snippets.map(s => `File: ${s.file}\n${s.content}`).join('\n\n')}

${previousFailures.length > 0 ? `Previous attempts failed:\n${previousFailures.map(f => f.error).join('\n')}` : ''}

Generate the FIXED code. The content must be the COMPLETE file content, not a diff. Provide a clear explanation of what changed.`;

    try {
      const result = await structuredModel.invoke(prompt);
      return {
        file: result.file,
        content: result.content,
      };
    } catch (e) {
      logger.warn('API for fix generation failed, using fallback...');
      return {
        file: snippets[0]?.file || "unknown.txt",
        content: "// Dry run fix generated by fallback due to API limits\n" + (snippets[0]?.content || ""),
      };
    }
  }

  async diagnoseFail(fix: CodeFix, testError: string): Promise<string> {
    const model = GeminiService.getModel('gemini-2.0-flash-exp');

    const prompt = `Test failed with this error:

\`\`\`
${testError}
\`\`\`

The code I wrote was:
\`\`\`
${fix.content}
\`\`\`

In ONE sentence, explain:
1. Why this failed
2. What needs to change

Be specific and actionable.`;

    const response = await model.invoke(prompt);
    // LangChain response content can be string or array of parts. For text models it is usually string.
    return typeof response.content === 'string' ? response.content : JSON.stringify(response.content);
  }
}

